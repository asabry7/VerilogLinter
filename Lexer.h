#pragma once

#include <string_view>
#include <string>
#include <unordered_set>
#include <iostream>
#include <cstdint>

// ==========================================
// 1. TOKEN DEFINITIONS
// ==========================================

/**
 * @brief Represents the various categories of tokens generated by the Lexer.
 */
enum class TokenType
{
    Identifier, ///< Names of variables, modules, ports, etc. (e.g., clk, reset, my_wire)
    Keyword,    ///< Reserved language keywords (e.g., module, always, if, begin, end)
    Number,     ///< Numeric literals (e.g., 4, 8'hFF, 0)
    Symbol,     ///< Operators and punctuation (e.g., +, -, <=, ;, (, ))
    Unknown,    ///< Unrecognized characters or invalid tokens
    EndToken    ///< End of File (EOF) / End of input stream marker
};

/**
 * @brief Represents a single lexical token extracted from the source code.
 */
struct Token
{
    TokenType type;           ///< The categorized type of the token
    std::string_view content; ///< The raw string view mapping exactly to the source text
};

// ==========================================
// 2. LEXICAL ANALYZER (LEXER)
// ==========================================

/**
 * @brief The Lexer class tokenizes a raw source code string.
 *
 * It scans the input string character by character, skips whitespaces and comments,
 * and groups the characters into meaningful structural tokens (Identifiers, Keywords,
 * Numbers, Symbols) to be consumed sequentially by the Parser.
 */
class Lexer
{
public:
    /**
     * @brief Construct a new Lexer object.
     *
     * @param src A string_view representing the entire source code to be tokenized.
     */
    Lexer(std::string_view src);

    /**
     * @brief Scans and retrieves the next available token from the source stream.
     *
     * @return Token The next valid token, or an EndToken if the end of file is reached.
     */
    Token next();

private:
    // --- Scanning State ---

    const char *current; ///< Pointer to the current character being analyzed (read head)
    const char *end;     ///< Pointer to the end of the source string (EOF boundary)

    // --- Helper Functions ---

    /**
     * @brief Checks if a character is a numeric digit (0-9).
     *
     * @param c The character to evaluate.
     * @return true if the character is a digit.
     */
    bool isDigit(char c);

    /**
     * @brief Checks if a character is valid for starting or continuing an identifier.
     *        Typically checks for alphabetic letters (a-z, A-Z) and underscores (_).
     *
     * @param character The character to evaluate.
     * @return true if it is an alphabetic character or underscore.
     */
    static inline bool isAlpha(char character);

    /**
     * @brief Checks if a character is whitespace (e.g., space, tab, newline, carriage return).
     *
     * @param character The character to evaluate.
     * @return true if it is a whitespace character.
     */
    static inline bool isSpace(char character);

    /**
     * @brief Checks if a given extracted string matches any registered language keyword.
     *
     * @param s The string view of the potential keyword.
     * @return true if it is a recognized keyword (e.g., "module", "endmodule").
     */
    static bool isKeyword(std::string_view s);
};